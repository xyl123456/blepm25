###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         31/Aug/2017  19:29:37 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\PM2.5\Projects\zstack\Samples\GenericApp\Source #
#                          \GenericApp.c                                      #
#    Command line       =  -f E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg         #
#                          (-DCPU32MHZ -DROOT=__near_func                     #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f       #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg           #
#                          (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\Source #
#                          \GenericApp.c -D ZIGBEEPRO -D ZTOOL_P1 -D          #
#                          xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D        #
#                          LCD_SUPPORTED=DEBUG -lC E:\PM2.5\Projects\zstack\S #
#                          amples\GenericApp\CC2530DB\CoordinatorEB-Pro\List\ #
#                           -lA E:\PM2.5\Projects\zstack\Samples\GenericApp\C #
#                          C2530DB\CoordinatorEB-Pro\List\ --diag_suppress    #
#                          Pe001,Pa010 -o E:\PM2.5\Projects\zstack\Samples\Ge #
#                          nericApp\CC2530DB\CoordinatorEB-Pro\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\ -I E:\PM2.5\Projects\zstack\Samples\Generic #
#                          App\CC2530DB\..\SOURCE\ -I                         #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\ZMAIN\TI2530DB\ -I                     #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\MT\ -I                #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I       #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\  #
#                          -I E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\    #
#                          -I E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\ -I   #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\AF\ -I          #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I         #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\SEC\ -I         #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I        #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\SYS\ -I         #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I         #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\ -I          #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I              #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\ -I    #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\ -I    #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ -I       #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\ -I    #
#                          E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\  #
#                          -I E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf0 #
#                          4\SINGLE_CHIP\ -Ohz --require_prototypes           #
#    List file          =  E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\CoordinatorEB-Pro\List\GenericApp.lst           #
#    Object file        =  E:\PM2.5\Projects\zstack\Samples\GenericApp\CC2530 #
#                          DB\CoordinatorEB-Pro\Obj\GenericApp.r51            #
#                                                                             #
#                                                                             #
###############################################################################

E:\PM2.5\Projects\zstack\Samples\GenericApp\Source\GenericApp.c
      1          /**************************************************************************************************
      2            Filename:       GenericApp.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5          
      6            Description:    Generic Application (no Profile).
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends "Hello World" to another "Generic"
     45            application every 15 seconds.  The application will also
     46            receive "Hello World" packets.
     47          
     48            The "Hello World" messages are sent/received as MSG type message.
     49          
     50            This applications doesn't have a profile, so it handles everything
     51            directly - itself.
     52          
     53            Key control:
     54              SW1:
     55              SW2:  initiates end device binding
     56              SW3:
     57              SW4:  initiates a match description request
     58          *********************************************************************/
     59          
     60          /*********************************************************************
     61           * INCLUDES
     62           */
     63          #include "OSAL.h"
     64          #include "AF.h"
     65          #include "ZDApp.h"
     66          #include "ZDObject.h"
     67          #include "ZDProfile.h"
     68          
     69          #include "GenericApp.h"
     70          #include "DebugTrace.h"
     71          
     72          #if !defined( WIN32 )
     73            #include "OnBoard.h"
     74          #endif
     75          
     76          /* HAL */
     77          #include "hal_lcd.h"
     78          #include "hal_led.h"
     79          #include "hal_key.h"
     80          #include "hal_uart.h"
     81          #include "hal_adc.h"
     82          #include "OSAL_Nv.h"
     83          #include "sht10.h"
     84          #include "bh1750.h"
     85          #include "types.h"
     86          
     87          /*********************************************************************
     88           * MACROS
     89           */
     90          #define HAL_LED_OFF   1
     91          #define HAL_LED_ON    0
     92          
     93          // This is the max byte count per OTA message.
     94          #if !defined( SERIAL_APP_TX_MAX )
     95          #define SERIAL_APP_TX_MAX  80
     96          #endif
     97          
     98          /*********************************************************************
     99           * CONSTANTS
    100           */
    101          
    102          /*********************************************************************
    103           * TYPEDEFS
    104           */
    105          
    106          /*********************************************************************
    107           * GLOBAL VARIABLES
    108           */
    109          
    110          // This list should be filled with Application specific Cluster IDs.
    111          const cId_t GenericApp_ClusterList[GENERICAPP_MAX_CLUSTERS] =
    112          {
    113            GENERICAPP_CLUSTERID
    114          };
    115          
    116          const SimpleDescriptionFormat_t GenericApp_SimpleDesc =
    117          {
    118            GENERICAPP_ENDPOINT,              //  int Endpoint;
    119            GENERICAPP_PROFID,                //  uint16 AppProfId[2];
    120            GENERICAPP_DEVICEID,              //  uint16 AppDeviceId[2];
    121            GENERICAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
    122            GENERICAPP_FLAGS,                 //  int   AppFlags:4;
    123            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    124            (cId_t *)GenericApp_ClusterList,  //  byte *pAppInClusterList;
    125            GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    126            (cId_t *)GenericApp_ClusterList   //  byte *pAppInClusterList;
    127          };
    128          
    129          // This is the Endpoint/Interface description.  It is defined here, but
    130          // filled-in in GenericApp_Init().  Another way to go would be to fill
    131          // in the structure here and make it a "const" (in code space).  The
    132          // way it's defined in this sample app it is define in RAM.
    133          endPointDesc_t GenericApp_epDesc;
    134          
    135          /*********************************************************************
    136           * EXTERNAL VARIABLES
    137           */
    138          
    139          /*********************************************************************
    140           * EXTERNAL FUNCTIONS
    141           */
    142          
    143          /*********************************************************************
    144           * LOCAL VARIABLES
    145           */
    146          byte GenericApp_TaskID;   // Task ID for internal task/event processing
    147                                    // This variable will be received when
    148                                    // GenericApp_Init() is called.
    149          devStates_t GenericApp_NwkState;
    150          
    151          
    152          byte GenericApp_TransID;  // This is the unique message ID (counter)
    153          
    154          afAddrType_t GenericApp_DstAddr;
    155          byte RxBuf[SERIAL_APP_TX_MAX+1];
    156          
    157          
    158          /*********************************************************************
    159           * 涉及的函数*/
    160          void GenericApp_HandleCombineKeys(uint16 keys, uint8 keyCounts);
    161          /*********************************************************************
    162           * APP design
    163           */
    164          //CRC校验码
    165          unsigned int Crc_tmp=0;
    166          //设置时间周期
    167          static uint16 Hour_time_cnt=0;
    168          static uint8 Day_time_cnt=0;
    169          /*********************************************************************
    170           * 设备采集数据
    171           */
    172          //static unsigned char Cmd_type;//报文类型
    173          static unsigned char Dev_mac[4]={0x00,0x00,0x00,0x00};//设备ID号
    174          #ifdef QTJC_DEV
    175          static unsigned char TVOC_data[3];//甲醛的值
    176          static unsigned char CO2_data[3];//co2的值
    177          #endif
    178          
    179          #ifdef POWER_TEST
    180          static unsigned char POW_data[3];//电量的值
    181          #endif
    182          
    183          static unsigned char PM25_data[3]={0x01,0x00,0x00};//PM2.5的值
    184          static unsigned char PM03_data[3]={0x0E,0x00,0x00};//PM0.3的值
    185          static unsigned char TEM_data[3]={0x03,0x00,0x00};//温度的值
    186          static unsigned char HUM_data[3]={0x04,0x00,0x00};//湿度的值
    187          
    188          static unsigned char Headline[2]={0xEB,0x90};
    189          static unsigned char Tialline[2]={0x0D,0x0A};
    190          
    191          static unsigned char Head_up_len[2]={0x00,0x0B};//心跳数据长度0X0B
    192          static unsigned char Rejest_up_len[2]={0x00,0x14};//数据注册上报长度0X14，身份登记
    193          static unsigned char Data_up_len[2]={0x00,0x1A};//数据上报长度0x17
    194          static unsigned char Confirm_up_len[2]={0x00,0x0B};//时间设置确认
    195          //static unsigned char Time_dp_len[2]={0x00,0x15};
    196          //static unsigned char Dev_dp_len[2]={0x00,0x0F};
    197          static unsigned char Dev_up_len[2]={0x00,0x0B};//设备ID写入返回长度
    198          static unsigned char Soft_version[3]={0x01,0x00,0x00};//软件版本号
    199          static unsigned char Hard_version[3]={0x01,0x00,0x00};//硬件版本号
    200          static unsigned char Time_set[3]={0x00,0x00,0x1E};//设置心跳时间30S
    201          static unsigned char Start_dev[3]={0x81,0x00,0x0A};//开机命令
    202          static unsigned char Stop_dev[3]={0x81,0x00,0x0B};//关机命令
    203          //定义PM2.5激光传感器头信息
    204          //static unsigned char PM25_Head[2]={0x42,0x4D};
    205          //static unsigned char PM25_len[2]={0x00,0x1C};
    206          static uint8 Receivebuf[40];//设备ID写入命令
    207          static uint8 Rece_len=0;//接收字节数
    208          
    209          
    210          Head_up_t     Head_up;
    211          Rejest_up_t   Rejest_up;
    212          Data_up_t     Data_up;
    213          Confirm_up_t  Confirm_up;
    214          Time_dp_t     Time_dp;
    215          Dev_dp_t      Dev_dp;
    216          Dev_up_t      Dev_up;
    217          PM25_up_t     Pm25_up;
    218          Dev_control_t Dev_ctl;
    219          Dev_control_res_t Dev_ctl_res;
    220          /*********************************************************************
    221           * LOCAL FUNCTIONS
    222           */
    223          void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    224          void GenericApp_HandleKeys( byte shift, byte keys );
    225          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    226          void GenericApp_SendTheMessage( void );
    227          void rxCB(uint8 port,uint8 event);//串口0回调函数
    228          void rxCB1(uint8 port,uint8 event);//串口1回调函数
    229          unsigned int Crc16(uint8 buf[],uint8 len);//crc校验函数
    230          void Heart_up(void);//心跳上传函数
    231          void write_to_nvflash(uint8 buf[]);//将设备ID写入到NVflash
    232          void read_from_nvflash(void);//读取设备ID到NVflash
    233          void Regest_dev(void);//设备通电上报
    234          void Data_up_process(void);//采集数据上报
    235          void Get_gass(void);//获取气体传感器值
    236          void Get_PM25(void);//获取PM2.5
    237          void Get_TEM_HUM();//获取温湿度
    238          void Confirm_up_process(void);//时间校对上传
    239          void Dev_dp_process(uint8 buf[]);//写入设备ID
    240          void Dev_up_process(uint8 buf[]);//设备ID写入上传
    241          void Dev_control_process(uint8 buf[]);//开关机命令
    242          
    243          static void Process_data(uint8 buf[],uint8 len);//处理串口数据
    244          #ifdef POWER_TEST
    245          void Get_power(void);
    246          #endif
    247          
    248          void Start_process(void);//开机处理函数
    249          void Stop_process(void);//关机处理函数
    250          
    251          /*********************************************************************
    252           * NETWORK LAYER CALLBACKS
    253           */
    254          
    255          /*********************************************************************
    256           * PUBLIC FUNCTIONS
    257           */
    258          
    259          /*********************************************************************
    260           * @fn      GenericApp_Init
    261           *
    262           * @brief   Initialization function for the Generic App Task.
    263           *          This is called during initialization and should contain
    264           *          any application specific initialization (ie. hardware
    265           *          initialization/setup, table initialization, power up
    266           *          notificaiton ... ).
    267           *
    268           * @param   task_id - the ID assigned by OSAL.  This ID should be
    269           *                    used to send messages and set timers.
    270           *
    271           * @return  none
    272           */
    273          void GenericApp_Init( byte task_id )
    274          {
    275            HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );//关闭PM2.5 
    276            //HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );//开启PM2.5
    277            
    278            halUARTCfg_t uartConfig;
    279            halUARTCfg_t uartConfig1;
    280            
    281            GenericApp_TaskID = task_id;
    282            GenericApp_NwkState = DEV_INIT;
    283            GenericApp_TransID = 0;
    284          
    285            // Device hardware initialization can be added here or in main() (Zmain.c).
    286            // If the hardware is application specific - add it here.
    287            // If the hardware is other parts of the device add it in main().
    288          
    289            /*GenericApp_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
    290            GenericApp_DstAddr.endPoint = 0;
    291            GenericApp_DstAddr.addr.shortAddr = 0;
    292            */
    293          
    294            // Fill out the endpoint description.
    295            GenericApp_epDesc.endPoint = GENERICAPP_ENDPOINT;
    296            GenericApp_epDesc.task_id = &GenericApp_TaskID;
    297            GenericApp_epDesc.simpleDesc
    298                      = (SimpleDescriptionFormat_t *)&GenericApp_SimpleDesc;
    299            GenericApp_epDesc.latencyReq = noLatencyReqs;
    300          
    301            // Register the endpoint description with the AF
    302            afRegister( &GenericApp_epDesc );
    303          
    304            // Register for all key events - This app will handle all key events
    305            RegisterForKeys( GenericApp_TaskID );
    306            //UART0,P02 P03
    307            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
    308            uartConfig.baudRate             = HAL_UART_BR_9600;
    309            uartConfig.flowControl          = FALSE;
    310            uartConfig.flowControlThreshold = 64;   // 2x30 don't care - see uart driver.
    311            uartConfig.rx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    312            uartConfig.tx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    313            uartConfig.idleTimeout          = 6;    // 2x30 don't care - see uart driver.
    314            uartConfig.intEnable            = TRUE; // 2x30 don't care - see uart driver.
    315            uartConfig.callBackFunc         = rxCB;
    316            HalUARTOpen (0, &uartConfig); 
    317            //UART1 P04 P05
    318            uartConfig1.configured           = TRUE;              // 2x30 don't care - see uart driver.
    319            uartConfig1.baudRate             = HAL_UART_BR_9600;
    320            uartConfig1.flowControl          = FALSE;
    321            uartConfig1.flowControlThreshold = 64;   // 2x30 don't care - see uart driver.
    322            uartConfig1.rx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    323            uartConfig1.tx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    324            uartConfig1.idleTimeout          = 6;    // 2x30 don't care - see uart driver.
    325            uartConfig1.intEnable            = TRUE; // 2x30 don't care - see uart driver.
    326            uartConfig1.callBackFunc         = rxCB1;
    327            HalUARTOpen (1, &uartConfig1);
    328            
    329            read_from_nvflash();//读取NV中的设备ID, to Dev_mac[3]
    330            // Update the display
    331            /*
    332           //ZDO注册信息
    333            ZDO_RegisterForZDOMsg( GenericApp_TaskID, End_Device_Bind_rsp );
    334            ZDO_RegisterForZDOMsg( GenericApp_TaskID, Match_Desc_rsp );
    335            //osal_set_event(GenericApp_TaskID,GENERICAPP_HUMI_MSG_EVT);
    336            */
    337            /*********************************************************************
    338           * 检测气体，CO2，H2S,甲醛等有害气体
    339           */
    340          #ifdef  QTJC_DEV 
    341            HalAdcSetReference (HAL_ADC_REF_AVDD);
    342            HalAdcInit();//初始化ADC，HAL_ADC_DEC_064
    343          #endif
    344          #ifdef POWER_TEST
    345            HalAdcSetReference (HAL_ADC_REF_AVDD);
    346            HalAdcInit();//初始化ADC，HAL_ADC_DEC_064
    347          #endif
    348            Regest_dev();//数据上报
    349            /*
    350            //设置周期性事件,心跳事件
    351            osal_start_timerEx( GenericApp_TaskID,
    352                                  GENERICAPP_HEART_EVT,
    353                                  GENERICAPP_SEND_MSG_TIMEOUT );
    354            */
    355          
    356              //设置周期性事件,数据采集上报
    357          osal_start_timerEx( GenericApp_TaskID,
    358                                  GENERICAPP_SEND_DATE_EVT,
    359                                  GENERICAPP_SEND_DATA_TIMEOUT );
    360          }
    361          
    362          /*********************************************************************
    363           * @fn      GenericApp_ProcessEvent
    364           *
    365           * @brief   Generic Application Task event processor.  This function
    366           *          is called to process all events for the task.  Events
    367           *          include timers, messages and any other user defined events.
    368           *
    369           * @param   task_id  - The OSAL assigned task ID.
    370           * @param   events - events to process.  This is a bit map and can
    371           *                   contain more than one event.
    372           *
    373           * @return  none
    374           */
    375          UINT16 GenericApp_ProcessEvent( byte task_id, UINT16 events )
    376          {
    377            afIncomingMSGPacket_t *MSGpkt;
    378           (void)task_id;  // Intentionally unreferenced parameter
    379           //GenericApp_TaskID = task_id;
    380          
    381              if ( events & SYS_EVENT_MSG )
    382              {
    383                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
    384                while (MSGpkt)
    385                {
    386                  switch ( MSGpkt->hdr.event ) 
    387                  {
    388                    case KEY_CHANGE:
    389                      GenericApp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    390                    break;
    391                    
    392                  default:
    393                    break;
    394                  }
    395                // Release the memory
    396                osal_msg_deallocate( (uint8 *)MSGpkt );
    397                // Next
    398                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
    399              }
    400              // return unprocessed events
    401              return (events ^ SYS_EVENT_MSG);
    402              }
    403           //心跳事件
    404           if ( events & GENERICAPP_HEART_EVT )
    405            {
    406              //时间设置和计算
    407              Hour_time_cnt++;
    408              if(Hour_time_cnt==2880)
    409              {
    410                Hour_time_cnt=0;
    411                Day_time_cnt++;
    412              }
    413              if(Day_time_cnt==30)
    414              {
    415                Day_time_cnt=0;
    416                Confirm_up_process();//30天时间校对
    417              }
    418              Heart_up();
    419              osal_start_timerEx( GenericApp_TaskID,
    420                                  GENERICAPP_HEART_EVT,
    421                                  GENERICAPP_SEND_MSG_TIMEOUT );
    422              
    423              return (events ^ GENERICAPP_HEART_EVT);
    424            }
    425            //发送数据事件
    426            if ( events & GENERICAPP_SEND_DATE_EVT )
    427            {
    428              //修改获取PM2.5温湿度
    429              //获取TVOC和CO2
    430              //Get_gass();
    431              //HalUARTWrite(0,Pm25_up.data_buf, 32);
    432              Get_PM25();
    433              Get_TEM_HUM();
                     ^
Error[Pa045]: function "Get_TEM_HUM" has no prototype
    434          #ifdef POWER_TEST
    435              Get_power();
    436          #endif
    437              Data_up_process();
    438              osal_start_timerEx( GenericApp_TaskID,
    439                                  GENERICAPP_SEND_DATE_EVT,
    440                                  GENERICAPP_SEND_DATA_TIMEOUT );
    441              return (events ^ GENERICAPP_SEND_DATE_EVT);
    442            }
    443            return 0;
    444          }
    445          
    446          /*********************************************************************
    447           * Event Generation Functions
    448           */
    449          
    450          /*********************************************************************
    451           * @fn      GenericApp_ProcessZDOMsgs()
    452           *
    453           * @brief   Process response messages
    454           *
    455           * @param   none
    456           *
    457           * @return  none
    458           */
    459          void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
    460          {
    461            switch ( inMsg->clusterID )
    462            {
    463              case End_Device_Bind_rsp:
    464                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
    465                {
    466                  // Light LED
    467                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
    468                }
    469          #if defined(BLINK_LEDS)
    470                else
    471                {
    472                  // Flash LED to show failure
    473                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
    474                }
    475          #endif
    476                break;
    477          
    478              case Match_Desc_rsp:
    479                {
    480                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
    481                  if ( pRsp )
    482                  {
    483                    if ( pRsp->status == ZSuccess && pRsp->cnt )
    484                    {
    485                      GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
    486                      GenericApp_DstAddr.addr.shortAddr = pRsp->nwkAddr;
    487                      // Take the first endpoint, Can be changed to search through endpoints
    488                      GenericApp_DstAddr.endPoint = pRsp->epList[0];
    489          
    490                      // Light LED
    491                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
    492                    }
    493                    osal_mem_free( pRsp );
    494                  }
    495                }
    496                break;
    497            }
    498          }
    499          
    500          /*********************************************************************
    501           * @fn      GenericApp_HandleKeys
    502           *
    503           * @brief   Handles all key events for this device.
    504           *
    505           * @param   shift - true if in shift/alt.
    506           * @param   keys - bit field for key events. Valid entries:
    507           *                 HAL_KEY_SW_4
    508           *                 HAL_KEY_SW_3
    509           *                 HAL_KEY_SW_2
    510           *                 HAL_KEY_SW_1
    511           *
    512           * @return  none
    513           */
    514          void GenericApp_HandleKeys( byte shift, byte keys )
    515          {
    516            zAddrType_t dstAddr;
    517            
    518            // Shift is used to make each button/switch dual purpose.
    519            if ( shift )
    520            {
    521              if ( keys & HAL_KEY_SW_1 )
    522              {
    523              }
    524              if ( keys & HAL_KEY_SW_2 )
    525              {
    526              }
    527              if ( keys & HAL_KEY_SW_3 )
    528              {
    529              }
    530              if ( keys & HAL_KEY_SW_6 )
    531              {
    532          
    533              }
    534            }
    535            else
    536            {
    537              if ( keys & HAL_KEY_SW_1 )
    538              {
    539              }
    540          
    541              if ( keys & HAL_KEY_SW_2 )
    542              {
    543                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
    544          
    545                // Initiate an End Device Bind Request for the mandatory endpoint
    546                dstAddr.addrMode = Addr16Bit;
    547                dstAddr.addr.shortAddr = 0x0000; // Coordinator
    548                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(), 
    549                                      GenericApp_epDesc.endPoint,
    550                                      GENERICAPP_PROFID,
    551                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
    552                                      GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
    553                                      FALSE );
    554              }
    555          
    556              if ( keys & HAL_KEY_SW_3 )
    557              {
    558              }
    559          
    560              if ( keys & HAL_KEY_SW_4 )
    561              {
    562                HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
    563                // Initiate a Match Description Request (Service Discovery)
    564                dstAddr.addrMode = AddrBroadcast;
    565                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
    566                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
    567                                  GENERICAPP_PROFID,
    568                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
    569                                  GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
    570                                  FALSE );
    571              }
    572            }
    573            if( keys & HAL_KEY_SW_6)
    574            {
    575              GenericApp_HandleCombineKeys(keys, halGetKeyCount());
    576            }
    577          }
    578          
    579          /*********************************************************************
    580           * LOCAL FUNCTIONS
    581           */
    582          
    583          /*********************************************************************
    584           * @fn      GenericApp_MessageMSGCB
    585           *
    586           * @brief   Data message processor callback.  This function processes
    587           *          any incoming data - probably from other devices.  So, based
    588           *          on cluster ID, perform the intended action.
    589           *
    590           * @param   none
    591           *
    592           * @return  none
    593           */
    594          void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
    595          {
    596            
    597          }
    598          
    599          /*********************************************************************
    600           * @fn      GenericApp_SendTheMessage
    601           *
    602           * @brief   Send "the" message.
    603           *
    604           * @param   none
    605           *
    606           * @return  none
    607           */
    608          void GenericApp_SendTheMessage( void )
    609          {
    610            afAddrType_t P2P_DstAddr;
    611            P2P_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
    612            P2P_DstAddr.endPoint = GENERICAPP_ENDPOINT;
    613            P2P_DstAddr.addr.shortAddr = 0xFFFF; //终端短地址在LCD上有显示，此处换成终端短地址就可以点播了。
    614          
    615            if ( AF_DataRequest( &P2P_DstAddr, &GenericApp_epDesc,
    616                                 GENERICAPP_CLUSTERID,
    617                                 1,
    618                                 RxBuf,
    619                                 &GenericApp_TransID,
    620                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    621            {
    622              // Successfully requested to be sent.
    623            }
    624            else
    625            {
    626              // Error occurred in request to send.
    627            }
    628          }
    629          void GenericApp_HandleCombineKeys(uint16 keys, uint8 keyCounts)
    630          {
    631            if(keys & HAL_KEY_SW_6)
    632            {
    633              switch( keyCounts)
    634              {
    635              case 0:
    636                 HalLedSet( HAL_LED_4, HAL_LED_MODE_OFF );
    637                break;
    638                case 1:
    639                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
    640                break;
    641              default: break;
    642              }
    643             
    644            }
    645          }
    646          
    647          
    648          
    649          static void rxCB(uint8 port,uint8 event)
    650          { 
    651            uint8 Uartbuf[40];//串口字符缓存区
    652            uint8 uartlen=0;
    653            uartlen = HalUARTRead(0,Uartbuf,sizeof(Uartbuf));
    654            if(uartlen>0){
    655              if((Uartbuf[0]==0xEB)&&(Uartbuf[uartlen-1]==0x0A)){
    656                //表示一帧数据结束,正常数据
    657                Rece_len=uartlen;
    658                osal_memcpy(Receivebuf,Uartbuf,Rece_len);
    659                Process_data(Receivebuf,Rece_len);
    660                 Rece_len=0;
    661                  osal_memset(Receivebuf,0,sizeof(Receivebuf));
    662                  osal_memset(Uartbuf,0,sizeof(Uartbuf));
    663              }else{
    664                osal_memcpy(Receivebuf+Rece_len,Uartbuf,uartlen);
    665                Rece_len=Rece_len+uartlen;
    666                if(Uartbuf[uartlen-1]==0x0A){
    667                  //封装结束,处理数据
    668                  Process_data(Receivebuf,Rece_len);
    669                  Rece_len=0;
    670                  osal_memset(Uartbuf,0,sizeof(Uartbuf));
    671                }
    672              }
    673            }
    674          }
    675          
    676          static void Process_data(uint8 buf[],uint8 len)
    677          {
    678            uint8 Datalen=len;
    679            uint8 Databuf[40];
    680            osal_memcpy(Databuf,buf,Datalen);
    681            if(Datalen==24)
    682               {
    683                   Dev_control_process(Databuf);
    684                }
    685            else if(Datalen==13)
    686               {
    687                 //设备ID修改命令
    688                      Dev_dp_process(Databuf);//处理下发控制设备ID
    689               }
    690                  else {
    691                      Datalen=0;
    692                      osal_memset(Databuf,0,sizeof(Databuf));
    693                  }
    694          }
    695          
    696          //串口1回调函数,更新激光PM2.5数据
    697          static void rxCB1(uint8 port,uint8 event)
    698          { 
    699            unsigned  char Uartbuf[40];//串口字符缓存区
    700            uint8 uartlen=0;
    701            uartlen = HalUARTRead(1,Uartbuf,sizeof(Uartbuf));
    702              if((uartlen==32)&&(Uartbuf[0]==0x42))
    703                {
    704                   osal_memcpy(Pm25_up.data_buf,Uartbuf,32);
    705                   uartlen=0;
    706                   osal_memset(Uartbuf,0,sizeof(Uartbuf));
    707                }else
    708                {
    709                   uartlen=0;
    710                   osal_memset(Uartbuf,0,sizeof(Uartbuf));
    711                }
    712          }
    713          unsigned int Crc16(uint8 buf[],uint8 len)
    714          {
    715          	unsigned int  i,j,c,crc;
    716          	crc=0xFFFF;
    717          	for(i=0;i<len;i++)
    718          		{
    719          		c=*(buf+i)&0xFF;
    720          		crc^=c;
    721          		for(j=0;j<8;j++)
    722          			{
    723          				if(crc & 0x0001)
    724          					{
    725          					crc>>=1;
    726          					crc ^=0xA001;
    727          					}
    728          				else
    729          					{
    730          					crc >>=1;
    731          					}
    732          			}
    733          		}
    734            return(crc);
    735          }
    736          
    737          
    738          
    739          void write_to_nvflash(uint8 buf[])
    740          {
    741              osal_nv_item_init(ZCD_DEV_ADDRESS, 1, NULL);
    742              osal_nv_write(ZCD_DEV_ADDRESS, 0,1, buf);
    743          }
    744          void read_from_nvflash(void)
    745          {
    746             osal_nv_item_init(ZCD_DEV_ADDRESS, 1, NULL);
    747             osal_nv_read(ZCD_DEV_ADDRESS, 0, 1, &Dev_mac[3]);
    748          }
    749          //心跳事件
    750          
    751          void Heart_up(void)
    752          {
    753            unsigned char chec_buf[2];
    754            uint16 chec_int=0;
    755            int i;
    756            osal_memcpy(Head_up.data_core.Head_byte,Headline,2);
    757            osal_memcpy(Head_up.data_core.Data_length,Head_up_len,2);
    758            Head_up.data_core.Data_type=0x01;
    759            osal_memcpy(Head_up.data_core.MAC_addr,Dev_mac,4);
    760            
    761            for(i=0;i<7;i++)
    762            {
    763              chec_int=chec_int+Head_up.data_buf[2+i];
    764            } 
    765            chec_buf[0]=chec_int>>8;
    766            chec_buf[1]=chec_int;
    767            osal_memcpy(Head_up.data_core.Check_code,chec_buf,2);
    768            osal_memcpy(Head_up.data_core.Tial,Tialline,2);
    769            HalUARTWrite(0, Head_up.data_buf, 13);
    770          }
    771          /*********************************************************************
    772           * 上电发送注册信息
    773           */
    774          void Regest_dev(void)
    775          {
    776            unsigned char chec_buf[2];
    777            uint16 chec_int=0;
    778            int i;
    779            osal_memcpy(Rejest_up.data_core.Head_byte,Headline,2);
    780            osal_memcpy(Rejest_up.data_core.Data_length,Rejest_up_len,2);
    781            Rejest_up.data_core.Data_type=0x02;
    782            osal_memcpy(Rejest_up.data_core.MAC_addr,Dev_mac,4);
    783            osal_memcpy(Rejest_up.data_core.Version,Soft_version,3);
    784            osal_memcpy(Rejest_up.data_core.HardVersion,Hard_version,3);
    785            osal_memcpy(Rejest_up.data_core.Heart_time,Time_set,3);
    786            for(i=0;i<16;i++)
    787            {
    788              chec_int=chec_int+Rejest_up.data_buf[2+i];
    789            } 
    790            chec_buf[0]=chec_int>>8;
    791            chec_buf[1]=chec_int;
    792            osal_memcpy(Rejest_up.data_core.Check_code,chec_buf,2);
    793            osal_memcpy(Rejest_up.data_core.Tial,Tialline,2);
    794            HalUARTWrite(0, Rejest_up.data_buf, 22);
    795          }
    796          /*
    797          采集数据上报命令
    798          */
    799          void Data_up_process(void)
    800          {
    801            unsigned char chec_buf[2];
    802            uint16 chec_int=0;
    803            int i;
    804            osal_memcpy(Data_up.data_core.Head_byte,Headline,2);
    805            osal_memcpy(Data_up.data_core.Data_length,Data_up_len,2);
    806            Data_up.data_core.Data_type=0x04;
    807            osal_memcpy(Data_up.data_core.MAC_addr,Dev_mac,4);
    808            osal_memcpy(Data_up.data_core.PM25,PM25_data,3);
    809            osal_memcpy(Data_up.data_core.PM03,PM03_data,3);
    810            osal_memcpy(Data_up.data_core.TEM,TEM_data,3);
    811            osal_memcpy(Data_up.data_core.HUM,HUM_data,3);
    812             osal_memcpy(Data_up.data_core.POW,POW_data,3);
    813            for(i=0;i<22;i++)
    814            {
    815              chec_int=chec_int+Data_up.data_buf[2+i];
    816            } 
    817            chec_buf[0]=chec_int>>8;
    818            chec_buf[1]=chec_int;
    819            osal_memcpy(Data_up.data_core.Check_code,chec_buf,2);
    820            osal_memcpy(Data_up.data_core.Tial,Tialline,2);
    821            HalUARTWrite(0, Data_up.data_buf, 28);
    822          }
    823          #ifdef QTJC_DEV
    824          void Get_gass(void)
    825          {
    826            uint16 QT_Tmp = HalAdcRead (HAL_ADC_CHANNEL_1, HAL_ADC_RESOLUTION_12);
    827            uint8 Temp_H=QT_Tmp>>8;    //高位在前
    828            uint8 Temp_L=QT_Tmp&0x00ff;//低位在后
    829            CO2_data[0]=0x07;
    830            CO2_data[1]=Temp_H;
    831            CO2_data[2]=Temp_L;
    832            TVOC_data[0]=0x08;
    833            TVOC_data[1]=Temp_H;
    834            TVOC_data[2]=Temp_L;
    835          }
    836          #endif
    837          
    838          #ifdef POWER_TEST
    839          void Get_power(void)
    840          {
    841             POW_data[0]=0x0A;
    842             POW_data[1]=0x00;
    843             //uint16 POW_Tmp = HalAdcRead (HAL_ADC_CHANNEL_0, HAL_ADC_RESOLUTION_12);
    844             uint16 POW_Tmp = HalAdcRead (HAL_ADC_CHANNEL_0, HAL_ADC_RESOLUTION_12);
    845          
    846             if(POW_Tmp>0x0320)
    847             {
    848             POW_data[2]=0x64; //100%
    849             }
    850             if((POW_Tmp>0x02BC)&&(POW_Tmp<0x0320))
    851             {
    852             POW_data[2]=0x3C; //60%
    853             }
    854             if((POW_Tmp>0x0258)&&(POW_Tmp<0x02BC))
    855             {
    856              POW_data[2]=0x28; //40%
    857             }
    858             if(POW_Tmp<0x00258)
    859             {
    860               POW_data[2]=0x0A;//10%
    861             }
    862          
    863          /*
    864             uint8 POW_H=POW_Tmp>>8;    //高位在前
    865             uint8 POW_L=POW_Tmp&0x00ff;//低位在后
    866             POW_data[0]=0x0A;
    867             POW_data[1]=POW_H;
    868             POW_data[2]=POW_L; 
    869             */
    870          }
    871          #endif
    872          
    873          void Get_PM25(void)
    874          {
    875           //获取PM25和PM03(1)数值，获取的是大气中的值
    876             osal_memcpy(PM25_data+1,Pm25_up.data_core.pm25_dq,2);
    877             osal_memcpy(PM03_data+1,Pm25_up.data_core.pm1_dq,2);
    878          }
    879          void Get_TEM_HUM()
    880          {
    881            SHT11_Finish();//获取温湿度
    882            /*直接获取值
    883            osal_memcpy(TEM_data+1,SHT11.Temp_byte,2);
    884            osal_memcpy(HUM_data+1,SHT11.Humi_byte,2);
    885            */
    886            //新协议基础值加03 E8
    887            uint16 data_sh=SHT11.Temp+0x03E8;
    888            TEM_data[1]=(data_sh>>8)&0xff;
    889            TEM_data[2]=data_sh&0xff;
    890            osal_memcpy(HUM_data+1,SHT11.Humi_byte,2);
    891            /*
    892            uint16 data_hum=SHT11.Humi;
    893            HUM_data[1]=(data_hum>>8)&0xff;
    894            HUM_data[2]=data_hum&0xff;
    895            */
    896          }
    897          void Confirm_up_process(void)
    898          {
    899            unsigned char chec_buf[2];
    900            uint16 chec_int=0;
    901            int i;
    902            osal_memcpy(Confirm_up.data_core.Head_byte,Headline,2);
    903            osal_memcpy(Confirm_up.data_core.Data_length,Confirm_up_len,2);
    904            Confirm_up.data_core.Data_type=0x0B;
    905            osal_memcpy(Confirm_up.data_core.MAC_addr,Dev_mac,4);
    906            for(i=0;i<11;i++)
    907            {
    908              chec_int=chec_int+Confirm_up.data_buf[2+i];
    909            } 
    910            chec_buf[0]=chec_int>>8;
    911            chec_buf[1]=chec_int;
    912            osal_memcpy(Confirm_up.data_core.Check_code,chec_buf,2);
    913            osal_memcpy(Confirm_up.data_core.Tial,Tialline,2);
    914            HalUARTWrite(0, Confirm_up.data_buf, 23);
    915          }
    916          void Dev_dp_process(uint8 buf[])
    917          {
    918            osal_memcpy(Dev_dp.data_buf,buf,13);
    919            unsigned char chec_buf[2];
    920            uint16 chec_int=0;
    921            int i;
    922              for(i=0;i<7;i++)
    923            {
    924              chec_int=chec_int + buf[2+i];
    925            } 
    926            chec_buf[0]=chec_int>>8;
    927            chec_buf[1]=chec_int;
    928            //判断校验位
    929            if(osal_memcmp(Dev_dp.data_core.Check_code,chec_buf,2))
    930            {
    931              osal_memcpy(Dev_mac,Dev_dp.data_core.MAC_addr,4);
    932              write_to_nvflash(&Dev_mac[3]);
    933              Dev_up_process(Dev_mac);//返回地址修改信息响应
    934            }else{
    935              osal_memset(buf,0,sizeof(buf));
    936            }
    937          }
    938          //修改地址信息返回
    939          void Dev_up_process(uint8 buf[])
    940          {
    941            unsigned char chec_buf[2];
    942            uint16 chec_int=0;
    943            int i;
    944            osal_memcpy(Dev_up.data_core.Head_byte,Headline,2);
    945            osal_memcpy(Dev_up.data_core.Data_length,Dev_up_len,2);
    946            Dev_up.data_core.Data_type=0xFE;
    947            osal_memcpy(Dev_up.data_core.MAC_addr,buf,4);
    948              for(i=0;i<7;i++)
    949            {
    950              chec_int=chec_int + Dev_up.data_buf[2+i];
    951            } 
    952            chec_buf[0]=chec_int>>8;
    953            chec_buf[1]=chec_int;
    954            osal_memcpy(Dev_up.data_core.Check_code,chec_buf,2);
    955            osal_memcpy(Dev_up.data_core.Tial,Tialline,2);
    956            HalUARTWrite(0, Dev_up.data_buf, 13);
    957          }
    958          //处理控制开关命令
    959          void Dev_control_process(uint8 buf[])
    960          {
    961            osal_memcpy(Dev_ctl.data_buf,buf,24);
    962            unsigned char chec_buf[2];
    963            uint16 chec_int=0;
    964            uint8 cmd_state=0;//0表示关机，1表示开机
    965            int i;
    966              for(i=0;i<18;i++)
    967            {
    968              chec_int=chec_int + buf[2+i];
    969            } 
    970            chec_buf[0]=chec_int>>8;
    971            chec_buf[1]=chec_int;
    972            //判断校验位
    973            if(osal_memcmp(Dev_ctl.data_core.Check_code,chec_buf,2))
    974            {
    975              if(osal_memcmp(Dev_ctl.data_core.MAC_addr,Dev_mac,4))
    976              {
    977                if(osal_memcmp(Dev_ctl.data_core.Cmd_code,Start_dev,3))
    978                {
    979                  //开机
    980                  cmd_state=1;
    981                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
    982                  Start_process();
    983                }
    984                if(osal_memcmp(Dev_ctl.data_core.Cmd_code,Stop_dev,3))
    985                {
    986                  //关机
    987                  cmd_state=0;
    988                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
    989                  Stop_process();
    990                }
    991                //返回信息
    992                osal_memcpy(Dev_ctl_res.data_buf,buf,24);
    993                Dev_ctl_res.data_core.Data_type=0x06;
    994                HalUARTWrite(0, Dev_ctl_res.data_buf, 24);
    995                osal_memset(buf,0,sizeof(buf));
    996                if(cmd_state==1)
    997                {
    998               //发送数据
    999                Get_PM25();
   1000                Get_TEM_HUM();
                       ^
Error[Pa045]: function "Get_TEM_HUM" has no prototype
   1001                #ifdef POWER_TEST
   1002                Get_power();
   1003                #endif
   1004                Data_up_process(); 
   1005                }
   1006              }else
   1007              {
   1008                osal_memset(buf,0,sizeof(buf));
   1009              }
   1010            }else{
   1011              osal_memset(buf,0,sizeof(buf));
   1012            }
   1013          }
   1014          
   1015          //开机处理函数
   1016          void Start_process(void)
   1017          {
   1018            //设置周期性事件,数据采集上报
   1019            osal_stop_timerEx( GenericApp_TaskID,GENERICAPP_SEND_DATE_EVT);
   1020            osal_start_timerEx( GenericApp_TaskID,
   1021                                  GENERICAPP_SEND_DATE_EVT,
   1022                                  GENERICAPP_SEND_DATA_TIMEOUT );
   1023          }
   1024          //关机处理函数
   1025          void Stop_process(void)
   1026          {
   1027            osal_stop_timerEx( GenericApp_TaskID,GENERICAPP_SEND_DATE_EVT);
   1028          }
   1029          
   1030          

Errors: 2
Warnings: none
